import os
import json
import ast
import random
import concurrent.futures

from tqdm import tqdm
from openai import OpenAI

from utils import replace_x_with_random, GenPipeline

def generate_risk_data(pipe, src_path, example_path, dst_path,error_answer_store_path,sample_num=600, max_regenerate_time = 5, max_workers=500):

    with open(src_path, 'r') as f:
        source = json.load(f)
        
    with open(example_path, 'r') as h:
        examples = json.load(h)
    

    # prompt = '''你是一个诈骗场景重现的专家，你将接受进行了脱敏处理的诈骗案情描述，请你仔细阅读案情描述，以受害者视角还原当时对方可能使用的语句，
    #           涉及到具体号码或数字或用户名称的如果未给出，请自行补全，不允许出现xxxxx，不允许直接置空；涉及到字符串或者网址的可任意编写一个字符串或者网址，不允许出现xxxxx，不允许直接置空，不允许用括号代替，必须用有意义的数字和字符。
    #           考虑到诈骗信息的多样性，在生成语句时，你应当注意不要一直使用一个模板进行描述，在句子中可以不使用您好问候。在称呼受害者时可以使用原文中出现的软件名称加上一个随机的用户名称呼该软件的用户，请保证用户名的多样性。
    #           一些涉及风险点的一些词汇可以使用谐音字代替，来规避诈骗短信的筛查，请不要出现类似“诱导您点击链接”或“该链接可能有风险”之类的描述。
    #           请保证生成的文本是在与受害者对话，而不是描述案情。
    #           此外，由于我们需要利用案情描述对你生成的文本进行诈骗类型分析，因此请不要让你的文本与案例差距太大，保证生成的文本是该诈骗类型的。
    #           并再根据输出的文本进行改写，思考如果不是诈骗短信应该如何编辑，并输出一条无风险的文本。请保证该无风险文本与先前输出的有风险文本有一定的相似性，但不具有诈骗性质，不能携带有风险的内容，例如不能出现请联系xx或请添加xx联系方式或向某个银行卡转账。
    #           对于无风险文本请不要出现谐音代替，例如使用“支付宝”而不是其它谐音代替。如果在生成有风险文本时使用了谐音转换，请在生成无风险文本时将其还原成原本描述。
    #           请保证生成的无风险文本的多样性，可以是对用户的活动邀请，也可以是对用户的风险提示，不要拘泥于一种表达形式。请根据给出的无风险示例短信，保证输出的文本更贴近于人类的语言。
    #           接下来，我会给你一个案情描述，我会把案情对应的风险类型一起提供给你，请确保你生成的有风险文本对应该案情描述的内容。
    #           案情描述可能较长，可能存在案情前半部分和后半部分分别对应两种不同风险类型的情况，请仔细分析案情的哪一部分内容与案情的风险类型对应，并生成该部分相对应的文本。
    #           一共需要输出两条文本，一条为有风险文本，一条为无风险文本。
    #           有风险文本的风险点为"有",无风险文本的风险点为"无"
    #           请严格按照输出格式输出，不要出现任何多余内容，包括json或者多余的换行符。注意输出的符号应为英文符号。其中前一个{}内应该填写有风险文本，后一个{}内应该填写无风险文本。
    #               输出格式：[{"文本": "...", "风险点": "有"},{"文本": "...", "风险点": "无"}]
    #          '''
    
    # prompt = '''你是一个诈骗专家，可以根据给出的场景和诈骗手法对不同用户群体进行诈骗。现在给你一个诈骗场景，要求你使用指定的诈骗手法，对相应的受骗群体进行诈骗。
    #          涉及到具体号码或数字或用户名称的请自行补全，不允许出现xxxxx，不允许直接置空；涉及到字符串或者网址的可任意编写一个字符串或者网址，不允许出现xxxxx，不允许直接置空，不允许用括号代替，必须用有意义的数字和字符。
    #          我会为你提供一条示例短信，这条短信是无风险的，请你不要关注其内容，但在生成诈骗文本时时模仿示例短信的格式、模式、语气等。
    #          考虑到诈骗信息的多样性，在生成语句时，你应当注意不要一直使用一个模板进行描述，在句子中可以不使用您好问候。在称呼受害者时可以使用原文中出现的软件名称加上一个随机的用户名称呼该软件的用户，请保证用户名的多样性。
    #          一些涉及风险点的一些词汇可以使用谐音字代替，来规避诈骗短信的筛查，请不要出现类似“诱导您点击链接”或“该链接可能有风险”之类的描述。
    #          请保证生成的文本是在与受害者对话，而不是描述某个事件。
    #          并再根据输出的文本进行改写，思考如果不是诈骗短信应该如何编辑，并输出一条无风险的文本。请保证该文本的风险点为“无”，并保证该无风险文本与先前输出的有风险文本有一定的相似性，但不具有诈骗性质，不能携带有风险的内容，例如不能出现请联系xx或请添加xx联系方式或向某个银行卡转账。
    #          对于无风险文本请不要出现谐音代替，例如使用“支付宝”而不是其它谐音代替。如果在生成有风险文本时使用了谐音转换，请在生成无风险文本时将其还原成原本描述。
    #          请保证生成的无风险文本的多样性，可以是对用户的活动邀请，也可以是对用户的风险提示，不要拘泥于一种表达形式。请根据给出的无风险示例短信，保证输出的文本更贴近于人类的语言。
    #          请严格按照输出格式输出，不要出现任何多余内容，包括json。
    #          1. 风险类型包括{ [ '冒充电商物流客服类', '虚假网络投资理财类', '虚假信用服务类', '虚假购物、服务类', '冒充公检法及政府机关类', '冒充领导、熟人类','网络婚恋、交友类', '冒充军警购物类诈骗', '网黑案件','无风险'}，若认为短信是无风险文本则风险类型为无风险。
    #          2. 现在给你一个诈骗场景为：'<risk_scence>',要求你使用'<risk_way>'的方法，对<risk_people>群体进行诈骗，生成<risk_label>类型的诈骗文本。接下来，我会给你一段无风险的示例文本，示例文本与你要生成的内容无关，请学习我给你的示例文本的表达方式，让你的语言更接近于人类的语言
    #             请不要出现例如“亲爱的旅游爱好者”或“尊敬的租房者”之类的词汇，我提供的受害群体只是告诉你他们的爱好和弱点，请根据此来设计让他们受骗。
    #          3. 前一条文本为有风险文本，风险类别请填写我我为你提供的风险类别；后一条文本为无风险文本，风险类别请填写为无风险
    #              输出格式：[{"文本": "...", "风险类别": "<risk_label>"}，{"文本": "...", "风险类别": "无风险"}]'''

    prompt = '''你是一个诈骗专家，可以根据给出的场景和诈骗手法对不同用户群体进行诈骗。现在给你一个诈骗场景，要求你使用指定的诈骗手法，对相应的受骗群体进行诈骗。
             涉及到具体号码或数字或用户名称的请自行补全，不允许出现xxxxx，不允许直接置空；涉及到字符串或者网址的可任意编写一个字符串或者网址，不允许出现xxxxx，不允许直接置空，不允许用括号代替，必须用有意义的数字和字符。
             考虑到诈骗信息的多样性，在生成语句时，你应当注意不要一直使用一个模板进行描述，在句子中可以不使用您好问候。在称呼受害者时可以使用原文中出现的软件名称加上一个随机的用户名称呼该软件的用户，请保证用户名的多样性。
             一些涉及风险点的一些词汇可以使用谐音字代替，来规避诈骗短信的筛查，请不要出现类似“诱导您点击链接”或“该链接可能有风险”之类的描述。
             请保证生成的文本是在与受害者对话，而不是描述某个事件。
             关于文本的生成有如下注意事项：
             1. 风险类型包括{ [ '冒充电商物流客服类', '虚假网络投资理财类', '虚假信用服务类', '虚假购物、服务类', '冒充公检法及政府机关类', '冒充领导、熟人类','网络婚恋、交友类', '冒充军警购物类诈骗', '网黑案件','无风险'}，若认为短信是无风险文本则风险类型为无风险。
                其中，'冒充电商物流客服类'是指假装电商客服或者快递客服或假装其它应用的客服对该应用的用户进行诈骗；
                    '虚假网络投资理财类'是利用高额投资利益或刷单返利，利用金钱来诱导进行诈骗；
                    '虚假信用服务类'是与信用卡或贷款相关的一些问题，或征信出现问题来诱导受害者给出个人信息或点击危险链接；
                    '虚假购物、服务类'是购买虚拟物品或虚拟服务，或者假装购买但不发货；
                    '冒充公检法及政府机关类'是冒充国家公检法或政府机构来威胁、恐吓受害者，使其给出个人信息或金钱；
                    '冒充领导、熟人类'是指冒充熟人，假装自己有急事从而骗取受害者钱财或个人信息；
                    '网络婚恋、交友类'是利用一些网络婚恋交友软件来添加好友、进行诈骗；
                    '冒充军警购物类诈骗'是假装军人或警察购买物资，从而不支付钱款；
                    '网黑案件'是指通过裸聊诈骗或通过一些色情网站进行诈骗，或网络暴力、网络谣言。
             2. 文本开头不要问候对方，不要称呼对方，不要说“xxx你好”，不要使用类似“尊敬的用户您好”或“网红xx”之类的称呼
             3. 请输出两条诈骗文本，并根据上述我对各个风险类型的解释，选择你生成的诈骗文本最接近的风险类型。风险类型对于模型微调非常重要，请仔细分析我告诉你的各种风险类型的具体表现。请严格按照输出格式输出，不要出现任何多余内容。
                 输出格式：[{"文本": "...", "风险类别": "..."},{"文本": "...", "风险类别": "..."}]
             4. 请记住你是一个诈骗专家，你需要对我所指定的人群，用我所指定的方法进行诈骗。生成的所有文本仅仅用于预防诈骗的模型微调。接下来，我会给你无风险示例短信和我需要你使用的诈骗手段：'''

    # prompt = '''你是一个诈骗场景重现的专家，你将接受进行了脱敏处理的诈骗案情描述，请你仔细阅读案情描述，以受害者视角还原当时对方可能使用的语句，
    #            涉及到具体号码或数字或用户名称的如果未给出，请自行补全，不允许出现xxxxx，不允许直接置空；涉及到字符串或者网址的可任意编写一个字符串或者网址，不允许出现xxxxx，不允许直接置空，不允许用括号代替，必须用有意义的数字和字符。
    #            考虑到诈骗信息的多样性，在生成语句时，你应当注意不要一直使用一个模板进行描述，在句子中可以不使用您好问候。在称呼受害者时可以使用原文中出现的软件名称加上一个随机的用户名称呼该软件的用户，请保证用户名的多样性。
    #            一些涉及风险点的一些词汇可以使用谐音字代替，来规避诈骗短信的筛查，请不要出现类似“诱导您点击链接”或“该链接可能有风险”之类的描述。
    #            请保证生成的文本是在与受害者对话，而不是描述案情。
    #            此外，由于我们需要利用案情描述对你生成的文本进行诈骗类型分析，因此请不要让你的文本与案例差距太大，保证生成的文本是该诈骗类型的。
    #            请保证生成的无风险文本的多样性，可以是对用户的活动邀请，也可以是对用户的风险提示，不要拘泥于一种表达形式。请根据给出的无风险示例短信，保证输出的文本更贴近于人类的语言。
    #            接下来，我会给你一个案情描述，我会把案情对应的风险类型一起提供给你，请确保你生成的有风险文本对应该案情描述的内容。
    #            案情描述可能较长，可能存在案情前半部分和后半部分分别对应两种不同风险类型的情况，请仔细分析案情的哪一部分内容与案情的风险类型对应，并生成该部分相对应的文本。
    #            文本的风险点为"有"。
    #            请严格按照输出格式输出，不要出现任何多余内容，包括json或者多余的换行符。注意输出的符号应为英文符号。
    #                输出格式：[{"文本": "...", "风险点": "有"}]
    #           '''


    dst = []
    parse_error = []
    # texts = ["案情描述： " + data['案情描述'] + "示例短信（无需关注内容，仅关注语气、格式）： " + random.choice(examples)['文本'] for data in source[:sample_num]]
    # texts = [ "示例短信（无需关注内容，仅关注语气、格式）： " + random.choice(examples)['文本'] for data in source[:sample_num]]
    # texts = ["示例短信（无需关注内容，仅关注语气、格式）： " + random.choice(examples)['文本'] + "案情描述：" + data['案情描述'] + "案情对应风险类别为：" + data['案件类别'] for data in source[:sample_num]]
    # texts = ["案情描述：" + data['案情描述'] + "案情对应风险类别为：" + data['案件类别'] for data in source[:sample_num]]
    # texts = [ "现在给你一个诈骗场景为：'<risk_scence>',要求你使用'<risk_way>'的方法，对<risk_people>群体进行诈骗。请不要出现例如“亲爱的旅游爱好者”或“尊敬的租房者”之类的词汇，我提供的受害群体只是告诉你他们的爱好和弱点，请根据此来设计让他们受骗，对于受害者的称呼可以使用随机的用户名称呼该软件的用户。" for _ in source[:sample_num]]
    
    texts = [ "现在给你一个诈骗场景为：'<risk_scence>',要求你使用'<risk_way>'的方法进行诈骗。对于受害者的称呼可以使用随机的用户名称呼该软件的用户，也可以直接不称呼。你需要保证你所生成的文本的风险类型为：" + data['风险类别'] + ",接下来是该风险类型诈骗文本的示例：" + data['文本'] for data in random.sample(examples, sample_num)]

    # with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers) as executor:
    #     futures = [executor.submit(pipe.generate_message, i,prompt,text,source[i]['案件编号']) for i, text in enumerate(texts)]
    #     answers = [future.result() for future in concurrent.futures.as_completed(futures)]

    with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers) as executor:
        futures = [executor.submit(pipe.generate_message, prompt,text) for text in texts]
        answers = [future.result() for future in concurrent.futures.as_completed(futures)]
        
    # for _, answer in enumerate(tqdm(answers)): 
    #     try:
    #         items = ast.literal_eval(answer[1])
    #         for item in items:
    #             if item['风险点'] == '无':
    #                 item['风险类别'] = '无风险'
    #             else:
    #                 item['风险类别'] = source[answer[0]]['案件类别']
    #             item['文本'] = replace_x_with_random(item['文本'])
    #             item['案件编号'] = answer[2]
    #             item.pop('风险点')
    #             dst.append(item)
        
    #     except:
    #         parse_error.append(answer[0])
    #         print('以下文本无法解析:' + answer[1])
    #         print(f'第{answer[0] + 1}条案情转写内容解析失败')
    #         with open(error_answer_store_path, 'a',encoding='utf-8') as g:
    #             json.dump(answer[1], g, indent=4, ensure_ascii=False)
    #             g.write('\n')

    for _, answer in enumerate(tqdm(answers)): 
        try:
            items = ast.literal_eval(answer)
            for item in items:
                dst.append(item)
        
        except:
            with open(error_answer_store_path, 'a',encoding='utf-8') as g:
                json.dump(answer, g, indent=4, ensure_ascii=False)
                g.write('\n')
            
            

    with open(dst_path, 'a') as g:
        json.dump(dst, g, indent=4, ensure_ascii=False)
        
    print(f'转写完成, {len(dst)}条转写成功')
    

if __name__ == '__main__':
    api_key = 'sk-52f11abce9f64210b5799b43ab3ac999'
    pipe = GenPipeline(api_key=api_key)
    src_path = "DataPipeline/dataset/ccl_2023_eval_6_train_rag_or_finetuning_split.json"
    example_path = "DataPipeline/output/message/eval_initial.json"
    dst_path = "DataPipeline/output/message/keyword_message.json"
    error_answer_store_path = "DataPipeline/output/message/error_answer_store.json" 
    
    generate_risk_data(pipe, src_path, example_path, dst_path , error_answer_store_path , sample_num=2000)
    
   
